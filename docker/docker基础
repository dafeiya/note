docker

===docker基础================================================================================================

docker是一种容器引擎，一种轻量级虚拟化的解决方案，为用户提供了创建和管理容器的便捷界面。
docker是一个开源项目，诞生于2013年处，由google推出

传统开发部署流程的弊端：
	1.单物理机多应用无法有效隔离(进程空间，cpu资源，磁盘)
	2.运维部署不便
	3.测试、版本管理复杂
	4.迁移成本高
	5.传统虚拟机空间占用大，启动慢，管理复杂
	......

docker轻量级容器化技术优势
	1.实现进程级别的隔离，可在普通服务器上激励上百个docker实例
	2.加快部署速度
	3.简化版本管理
	4.秒级启动，秒级停止，空间资源占用极少

docker应用方向
	1.简化配置：使应用能够无缝运行在任何平台，将应用环境与底层运行环境实现了解耦
	2.代码管道化管理：代码从开发者机器到生产环境机器进行管道化管理，实现平滑迁移
	3.应用隔离：多个应用服务不熟在多个docker中，实现应用之间的解耦
	4.服务合并：合并多个服务，减少机器的占用
	5.快速部署：快速的启动速递，极少的空间占用
	6.集群化管理：实现在单机上搭建分布式集群服务，从而能够测试在真正生产环境下的代码

-------------------------------------------------------------------------
docker重要概念：
	镜像(image)、容器(container)、数据卷(volumes)、链接(links)、仓库(repository)

	1.镜像：
		docker的镜像类似虚拟机的快照，但是更轻量。docker的镜像就是一个只读的模板。
		镜像可以用来创建容器。可以从同一个镜像中启动多个容器
		例如，一个镜像可以包含一个完整的linuxOS环境，里面仅安装你需要的应用程序如tomcat等。docker提供了一个很简单的机制来创建images或者更新现有的images，你甚至可以直接从其它人那里下载一个已经做好的images。
	2.容器：
		容器是从镜像创建来的运行实例。等同于从快照中创建的虚拟机。它可以被启动、开始、停止、删除。每个容器都是相互隔离、安全的平台。
		可以把容器看做是一个简易瘦身版的linux环境(仅包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序
		容器中可以进行端口映射
	3.数据卷：
		数据卷是一个可供一个或多个容器使用的特殊目录。可以在多个容器之间共享数据卷
		数据卷可用于数据的持久化，数据卷实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。从而实现进程和数据的分离。
		数据卷类似与linux下对目录或文件进行mount
	4.链接：
		容器的链接系统是除了端口映射外，另一种跟容器中的应用进行交互的方式
		在源容器和接收容器之间创建一个隧道，只有接收容器可以看到源容器指定的信息。而其它容器无法看到源容器的这些指定信息，如容器端口等。
		docker在两个互联的容器之间创建了一个安全隧道，而且不需要映射它们的端口到宿主主机上。从而避免了暴露关键系统(如数据库)端口到外部网络上。
	5.仓库及仓库注册服务器：
		1.仓库是集中存放镜像文件的场所
		2.仓库注册服务器上通常存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签
		3.仓库分为公开仓库(public)和私有仓库(private)两种形式
		4.push镜像到仓库，从仓库pull下拉镜像
	
-------------------------------------------------------------------------
docker的技术基础：

1.NameSpace实现资源隔离：
	1.UTS:主机名隔离
	2.IPC:进程间通信隔离
	3.PID:进程树隔离
	4.NS:挂载点隔离
	5.NET:网络接入，包括接口的隔离
	6.USER:将本地的虚拟user-id映射到真实的user-id
2.CGROUP限额控制
  计算机资源使用上的隔离，通常称之为使用限额
  Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
  Priorization：优先级控制，比如:cup利用和磁盘io吞吐
  Account：一些神级和统计，主要目的是为了计费
  Control：挂起进程，回复执行进程
	1.CGROUP-CPU使用限制
3.Union文件系统
	功能类似diff命令，通过分层的方式记录文件的累积变化情况。
	例如tomcat,oracle,weblogic镜像都可以共享同一个linux基础镜像，每一个镜像保存的只是在基础镜像上他们修改的部分。
	docker的镜像可以非常多，但是每个都很小，因此加载启动非常快

-------------------------------------------------------------------------
docker使用步骤：
	1.创建镜像
	2.创建容器
	3.在需要是暴露端口，创造数据卷等
	4.通过链接将几个容器连接在一起
	...
	
===2.常用命令及说明======================================================================================
1.  docker images	
	显示本地docker上的所有镜像，会显示所在仓库、版本、id等信息

2.	docker search redis			
	docker search training/sinatra
	很多人已经创建了各种不同用途的images,并将它们上传到了docker hub的公共仓库上，我们可以在公众仓库https://hub.docker.com上直接查找合适的镜像
	通常使用一个单词作为它们名字的被成为基础镜像或者根镜像。它们由docker公司创建、验证、支持；还有一种类型，比如training/sinatra镜像。它们通常是由用户创建并维护的，需要通过指定镜像名称的前缀来指定它们。

3.  docker pull centos:latest	
	获取指定的镜像,当我们启动容器使用的image不在本地主机上时，docker会自动下载他们，不指定镜像版本时默认为latest

4.	创建自己的镜像：
	方式一： 使用docker commit来扩展一个image
		1> sudo docker run -i -t centos /bin/bash	启动centos镜像（注意，记下启动后的容器id）
		2> 使用yum安装所要添加的包或做其它修改
		3> 退出容器，sudo docker commit -m="add new package" -a="" <containerId>  <newImageName>
		使用dicker commit来扩展一个镜像比较简单，但这不容易在一个团队中分享它。因此有了dockerfile的方式来创建镜像
	
	方式二：从dockerfile来创建image
		dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中的调用任何命令。docker通过读取dockerfile中的指令自动生成镜像。
		1> docker build -f /mycentos/centosdockerfile   使用build命令根据指定的dockerfile文件来构建映像，-f用于指定dockerfile文件的位置
		dockerfile中的指令被一条条地执行。每一步都创建了一个新的容器，当左右的指令都执行完毕以后，返回了一个镜像id，并且所有的中间步骤所产生的容器都被删除和清理了。

5.  docker push <images>
	上传镜像

6.	docker ps -a 
	查询容器

7.	docker rm id1 id2 ...
 	删除容器   删除容器前必须保证容器是停止的，删除镜像前必须要先删除依赖它的容器

1. docker run -i -l  busybox:latest /bin/bash
	1> 如果本地有busybox这个镜像就直接用它来创建容器，否则从共有仓库下载
	2> 从版本号为latest的busybox镜像中创建容器，不指定时默认为latest最新版本
	3> 分配一个文件系统，并在支付的image层外面挂载一层可读写的层
	4> 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
	5> 从地址池配置一个ip地址给容器
	6> 执行你指定的程序，进入一个子bash中，-i -l 用于重定向标准输入输出

	
-------------------------------------------------------------------------






===3.dockerfile文件详解======================================================================================

Dockerfile的基本结构：
	Dockerfile 一般分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动时执行指令。

Dockerfile文件说明：
	Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是FROM。一个声明以＃字符开头则被视为注释。可以在Docker文件中使用RUN，CMD，FROM，EXPOSE，ENV等指令。
--------------------------------------------------------------------
1.FROM指令	
格式：
　　FROM <image>
　　FROM <image>:<tag>
　　FROM <image>@<digest>
示例：
　　FROM mysql:5.6
注：
　　tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像

--------------------------------------------------------------------

2.MAINTAINER: 维护者信息

格式：
    MAINTAINER <name>
示例：
    MAINTAINER Jasper Xu
    MAINTAINER sorex@163.com
    MAINTAINER Jasper Xu <sorex@163.com>
--------------------------------------------------------------------
3.RUN：构建镜像时执行的命令

RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：
3.1> shell执行
格式：
    RUN <command>

3.2> exec执行
格式：
    RUN ["executable", "param1", "param2"]
示例：
    RUN ["executable", "param1", "param2"]
    RUN apk update
    RUN ["/etc/execfile", "arg1", "arg1"]
注：
　　RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache

--------------------------------------------------------------------
3.ADD：将本地文件添加到容器中，tar类型文件会自动解压，可以访问网络资源，类似wget

格式：
    ADD <src>... <dest>
    ADD ["<src>",... "<dest>"] 用于支持包含空格的路径
示例：
    ADD hom* /mydir/          # 添加所有以"hom"开头的文件
    ADD hom?.txt /mydir/      # ? 替代一个单字符,例如："home.txt"
    ADD test relativeDir/     # 添加 "test" 到 `WORKDIR`/relativeDir/
    ADD test /absoluteDir/    # 添加 "test" 到 /absoluteDir/

--------------------------------------------------------------------
4.COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源

--------------------------------------------------------------------
5.CMD：构建容器后调用，也就是在容器启动时才进行调用。

格式：
    CMD ["executable","param1","param2"] (执行可执行文件，优先)
    CMD ["param1","param2"] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)
    CMD command param1 param2 (执行shell内部命令)
示例：
    CMD echo "This is a test." | wc -
    CMD ["/usr/bin/wc","--help"]
注：
 　　CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。
--------------------------------------------------------------------
6.ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去"application"，只使用参数。

格式：
    ENTRYPOINT ["executable", "param1", "param2"] (可执行文件, 优先)
    ENTRYPOINT command param1 param2 (shell内部命令)
示例：
    FROM ubuntu
    ENTRYPOINT ["top", "-b"]
    CMD ["-c"]
注：
　　　ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。

--------------------------------------------------------------------
7.LABEL：用于为镜像添加元数据

格式：
    LABEL <key>=<value> <key>=<value> <key>=<value> ...
示例：
　　LABEL version="1.0" description="这是一个Web服务器" by="IT笔录"
注：
　　使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。

--------------------------------------------------------------------
8.ENV：设置环境变量

格式：
    ENV <key> <value>
    ENV <key>=<value> ...
示例：
    ENV myName John Doe
    ENV myDog Rex The Dog
    ENV myCat fluffy
--------------------------------------------------------------------
9.EXPOSE：指定于外界交互的端口

格式：
    EXPOSE <port> [<port>...]
示例：
    EXPOSE 80 443
    EXPOSE 8080
注：
　　EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口

--------------------------------------------------------------------
10.VOLUME：用于指定持久化目录

格式：
    VOLUME ["/path/to/dir"]
示例：
    VOLUME ["/data"]
    VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"
注：
　　一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：
		1 卷可以容器间共享和重用
		2 容器并不一定要和其它容器共享卷
		3 修改卷后会立即生效
		4 对卷的修改不会对镜像产生影响
		5 卷会一直存在，直到没有任何容器在使用它

--------------------------------------------------------------------
11.WORKDIR：工作目录，类似于cd命令

格式：
    WORKDIR /path/to/workdir
示例：
    WORKDIR /a  (这时工作目录为/a)
    WORKDIR b  (这时工作目录为/a/b)
    WORKDIR c  (这时工作目录为/a/b/c)
注：
　　通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。
--------------------------------------------------------------------
12.USER:指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户

 格式:
　　USER user
　　USER user:group
　　USER uid
　　USER uid:gid
　　USER user:gid
　　USER uid:group

 示例：
　　USER www

 注：
　　使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。
--------------------------------------------------------------------
13.ARG：用于指定传递给构建运行时的变量

格式：
    ARG <name>[=<default value>]
示例：
    ARG site
    ARG build_user=www

--------------------------------------------------------------------
示例：
# This my first nginx Dockerfile
# Version 1.0

# Base images 基础镜像
FROM centos

#MAINTAINER 维护者信息
MAINTAINER tianfeiyu 

#ENV 设置环境变量
ENV PATH /usr/local/nginx/sbin:$PATH

#ADD  文件放在当前目录下，拷过去会自动解压
ADD nginx-1.8.0.tar.gz /usr/local/  
ADD epel-release-latest-7.noarch.rpm /usr/local/  

#RUN 执行以下命令 
RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm
RUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre && yum clean all
RUN useradd -s /sbin/nologin -M www

#WORKDIR 相当于cd
WORKDIR /usr/local/nginx-1.8.0 

RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre && make && make install

RUN echo "daemon off;" >> /etc/nginx.conf

#EXPOSE 映射端口
EXPOSE 80

#CMD 运行以下命令
CMD ["nginx"]

--------------------------------------------------------------------
--------------------------------------------------------------------
--------------------------------------------------------------------
--------------------------------------------------------------------
--------------------------------------------------------------------
--------------------------------------------------------------------










