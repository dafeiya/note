
===========================================结构化并发程序===============================================
6.任务执行：
	大多数并发应用程序都是围绕"任务执行(Task Execution)"来构造的：任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的失误边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
	
	6.1 在线程中执行任务：
		1.单个线程串行执行
		2.为每个任务分配一个线程
	6.2 Executor框架：
		任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。我们已经分析了两种通过线程来执行任务的策略，即把所有任务放在单个线程中串行执行，以及将每个任务放在各自的线程中执行。这两种方式都存在一些严格的限制：串行执行的问题在于其糟糕的响应性和吞吐量，而"为每个任务分配一个线程"的问题在于资源管理的复杂性。
		在java类库中，任务执行的主要抽象对象不是Thread，而是Executor。线程池简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池实现作为Executor框架的一部分。
			public interface Executor {
				void execute(Runnable command);
			}
		虽然Executor是个简单的接口，但它却为灵活且强大的异步任务执行框架提供了基础，该框架支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现类中还提供了对生命周期的支持，以及统计信息手机、应用程序管理机制和性能监视等机制。
		Executor基于生产者――消费者模式，提交任务的操作相当于生产者(生成待完成的工作单元)，执行任务的线程则相当于消费者(执行完这些工作单元)。如果要在程序中实现一个生产者――消费者的设计，那么最简单的方式通常就是使用Executor。
		6.2.1 执行策略：
			通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。包括：
				1.在什么线程中执行任务？
				2.任务按照什么顺序执行(FIFO、LIFO、优先级)?
				3.有多少个任务能并发执行？
				4.在队列中有多少个任务在等待执行？
				5.如果系统由于过载需要拒绝一个任务，那么应该选择哪一个任务？另外如何通知应用程序有任务被拒绝？
				6.在执行一个任务之前或之后，应该进行哪些操作?
		6.2.2 线程池：
			通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上发送竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。
			线程池，从字面含义看，是指管理一组同构工作线程的资源池。线程池是与工作队列(Work Queue)密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程(Worker Thread)的任务很简单，从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
			"在线程池中执行任务"比"为每个任务分配一个线程"优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁规程中产生的巨大开销。类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors的静态工厂方法之一来创建一个线程池:
				newFixedThreadPool:创建一个限制最大长度的线程池，每提交一个任务就创建一个线程，直到达到线程池的最大数量。返回ThreadPoolExecutor实例。
				newCachedThreadPool:创建一个可缓存的线程池，当线程池的当前规模超过了处理需求，将回收空闲的线程; 当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。返回ThreadPoolExecutor实例。
				newSingleTreadExecutor:创建一个单线程的Executor来执行任务。如果这个线程因为异常而结束，会创建另一个线程来代替。它可以通过创建不同的任务队列来确保任务的执行顺序，例如FIFO、LIFO、优先级队列。此外newSingleTreadExecutor还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的，这意味着，即使这个线程会不时地被另一个线程替代，但对象总是可以安全地封闭在"任务线程中"。
				newScheduledThreadPool:创建一个固定长度的线程池，而能够且以延迟或定时的方式来执行任务，类似于Timer
			从"为每个任务分配一个线程"策略编程基于线程池的策略，将对应用程序的稳定性产生重大的影响：web服务器不会再在高负载情况下失败。由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其它功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。
		
		6.2.3 Executor的生命周期
			上面我们谈到如何创建一个Executor，但并没有讨论如何关闭它。Executor的实现通常会创建线程来执行任务。但JVM只有在所有线程(非守护)线程全部终止后才会退出。因此如果无法正确关闭Executor，那么JVM将无法结束。
			为了解决执行服务的生命周期问题，ExecutorService接口对Executor进行了扩展，添加了一些用于生命周期管理的方法(同时还有一些用于任务提交的方法)。
				public interface ExecutorService extends Executor {
					void shutdown();
					list<Runnable> shutdownNow();
					boolean isShutdown();
					boolean isTerminated();
					boolean awaitTermination(long timeout,TimeUnit unit) throws InterruptedException;
				}
			ExecutorService的生命周期有3钟状态: 运行、关闭、已终止。
				ExecutorService在初始创建时处于运行状态。
				shutdown方法将执行平缓的关闭过程，不再接受新的任务，同时等待已经提交的任务执行完成――包括那些还未开始执行的任务。
				shutdownNow方法将执行粗暴的关闭过程，它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。
		6.2.4 延迟任务与周期任务
			Timer类负责管理延迟任务("在100ms后执行该任务")以及周期任务("每10ms执行一次该任务")。然而，Timer存在一些缺陷，因此应该使用ScheduledThreadPoolExecutor来替代它。在jdk5.0以后，将很少使用Timer
			Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其它TimerTask的定时精确性。例如某个周期TimerTask需要每10ms执行一次，而另一个TimerTask需要执行40ms，那么这个周期任务或者在40ms任务执行完成后快速连续地调用4次，或者彻底"丢失"4次调用(取决于是基于固定速率来调度还是基于固定延时来调度)。而线程池能弥补这个缺陷，它可以提供多个线程来执行延时任务和周期任务。
			Timer的另一个问题，如果TimerTask抛出了一个未检查的异常，那么Timer将表现出糟糕的行为。Timer线程并不捕获异常，因此当TimerTask抛出未检查的异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度(线程泄漏[Thread Leakage])。
		6.2.5 DelayQueue
			如果要头肩自己的调度任务，那么可以用DelayQueue，它实现了BlockQueue，并为ScheduledThreadPoolExecutor提供调度功能。DelayQueue管理着一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有当某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据它们的延迟时间进行排序。
	6.3 携带结果的任务Callable与Future：
		Executor框架使用Runnable作为其基本的任务表示形式，因此要使用Executor框架必须将任务描述为一个Runnale。Runnable是一种有很大局限性的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个检查的异常。
		许多任务实际上都是存在延迟的计算――执行数据库查询、从网络上获取资源，或计算某个复杂的功能等。对于这些任务，Callable是一种更好的抽象：它认为主入口点(即call)将返回同一个值，并可能抛出一个异常。在Executor中包含了一些辅助方法能将其它类型的任务封装为一个Callable，例如Runnable和java.security.PrivilegedAction。
		Runnable和Callable描述的都是抽象的计算任务。这些任务通常都是有范围的，即都有一个明确的起始点，并且都会结束等。Executor执行的任务有4个生命周期阶段:创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。
		Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获得任务的结果和取消任务等。
		CompletionService：
			将Executor和BlockingQueue的功能融合在一起，你可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor
			ExecutorCompletionService的实现非常简单。在构造函数中创建一个BlockingQueue来保存计算完成的结果。当计算完成时，调用Future-Task中的done方法。当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，并将结果放入BlockingQueue

7.任务的取消与关闭：
	任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行体质。然而有时候我们希望提前结束任务或线程，或许 因为用户点击了取消操作，或者应用程序需要被快速关闭。
	要使任务和线程安全、快速、可靠地停下来，并不是一件容易的事情。java目前没有提供任何机制来安全地终止线程。但它提供了中断(Interruption)，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。
	这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：当需要停止时，它们首先会清除当前正在执行的任务，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。
	7.1任务取消：
		如果外部代码能在某个操作正常完成之前将其置入"完成"状态，那么这个操作就可以称为可取消(Cancellable)。取消某个操作的原因有很多：
			1.用户请求取消
			2.有时间限制的操作，当计时器超时，需要取消所有正在搜索的任务
			3.应用程序事件，例如应用程序对某个问题空间进行分解并搜索，从而使不同的任务可以搜索问题空间中的不同区域。当其中一个任务找到了解决方案时，所有其它还在进行的任务都应该被取消
			4.错误。例如爬虫任务发生错误时(例如磁盘已满)，那么所有搜索任务都会被取消，此时可能会记录它们的当前状态，以便稍后重新启动。
			5.程序关闭。当一个程序或服务关闭时，必须对正在处理和等待处理的工作执行某种操作。在平缓的关闭过程中，当前正在执行的任务将继续执行直到完成，而在立即关闭过程中，当前的任务则可能被取消
		7.1.1 请求取消标志
			其中一种协作机制能设置某个"已请求取消(Cancellation Request)"标志(必须用volatile修饰)，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。
			另一种协作机制是当逻辑中有sleep等阻塞方法时，将cancel功能写到finally代码块中，以保证线程即使被中断也能调用cancel方法。如果cancel没有被调用，那么处理线程将永远运行下去，不断消耗CPU时钟周期，并使得JVM无法正常退出。
		7.1.1 中断机制：
			通过"请求取消标志"的机制虽然最终会使得任务退出，但在退出的过程中却需要花费一定的时间(轮询该标志所花费的时间)。然而如果使用这种方法的任务调用了一个阻塞方法，例如BlockQueue.put,那么可能产生一个更严重的问题――任务可能永远不会检查取消标志，因此永远不会结束！
			在java的API语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消功能之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前的工作，并转而执行其它的工作。而中断机制是实现任务取消的最合理的方式。
				public class Thread { //线程中的中断方法
					public void interrupt(){}
					public boolean isInterrupted(){}
					public static boolean interrupted(){}
					...
				}
			线程的中断机制改变的是线程中的属性，而阻塞方法(如Thread.sleep、Object.wait)等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，并抛出InterruptedException，表示阻塞操作由于中断而提前结束。虽然JVM并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。
			当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断是否发生了中断。通过这种
			


































		