=====1.概要总览=================================================================
1.数据库查询优化技术(Query of Optimization)

	数据库查询优化技术一直是DBMS实现技术中的精华，也是重点和难点。且查询优化技术的原理在各类DBMS系统和搜索系统中具有普适性。
	数据库中的sql语言是基于数学中的关系代数，关系代数是一种抽象的查询语言，用对关系运算来表达查询，作为研究关系语言的数学工具。关系代数的运算对象是关系，运算结果也是关系。
	数据库调优是针对数据库整体，以期提高DB的吞吐量缩短DB的响应时间；查询语句调优是针对一条查询语句，使其有更高的执行效率。
	
	广义查询优化技术涉及的主要方面：
		1.查询重用(Query Reuse)
			>查询结果的重用
				消耗内存但是节约CPU和IO消耗
			>执行计划的重用
		2.查询重写规则(Query Rewrite)
			>基于关系代数等规则所进行的等价查询转换
			>视图重写优化、子查询优化、等价位置重写、条件优化、链接、外链接和嵌套链接的消除等
			>语义优化
		3.查询优化算法(Algorithm of Query Optimization)
			基于代价估算模型对各类操作进行代价估算，求解最小代价
			>单表扫表优化算法
			>两表连接优化算法
			>多表连接优化算法
		4.并行查询优化(Parallel Query Optimization)
			拆解sql的执行部分并行执行节省整体的查询时间
		5.分布式查询优化(Distribute Query Optimization)
			分布式处理

	
1.3 查询执行计划(Query Plan)
	查询优化：
		查询优化是求解给定的查询语句的高效执行计划的过程这个过程中有很多个子步骤，每一个子步骤就是一个子问题，而不同的子问题对应了不同的解决方法，计算法。
		综上，查询优化是一种结合多种算法求解最优查询计划的过程。

	查询计划是一棵二叉树，也称为查询树，它是由一系列内部的操作符组成，这些操作符按照一定的运算关系构成查询的一个执行方案。查询树上有不同的结点,不同的结点有不同的解决方案，一下为常见结点的处理方式：
	1.单表结点的数据获取(从物理存储到内存存储)：
		1.直接通过IO获取数据.(全表扫描 Full Text)
		2.通过索引获取数据.(索引只读扫描)
		3.通过索引定位数据的位置后再通过IO从数据块中获取数据.(索引扫描)
	2.两表连接结点：
	两表连接时，各表数据已经经过单表结点完成数据的获取，两表连接是来考虑对表以何种方式连接、代价多大、连接路径有哪些等问题。怎么对单表元组数据进行连接。
	两表连接是一种局部
	不同的连接算法导致连接的效率不同，进而影响着整体的查询效率。
	3.多表连接结点：
		考虑多表连接数据如何构成代价最小的"执行计划"

	生成最优查询计划的策略：
		1.基于规则的优化
		2.基于成本的优化
			总成本=IO成本+CPU成本
		3.两者结合使用


2.逻辑查询优化(Login Query Optimization)
	查询的基本操作：
		1.选择操作(对应的是where中的限制条件)
			优化方式:使用范围更小更精确的限制条件(如'=','>'等)尽量减少连接操作前的元组数，使得中间临时关系尽量少，从而减少IO和CPU以及内存的消耗。
		2.投影操作(对应的是select查询的目标列)
			优化方式:减少连接操作前的列数，使得中间临时关系尽量小。
			注意：选择操作是减少行，投影操作是减少列
		3.连接操作(面向多表的连接)
			>多表连接中各个表被连接的顺序决定着效率
			>多表连接时多表的连接顺序和连接方式(左右内外连接)是被用户语义所决定的，不同的连接语义产生的结果集数据是不同的
			优化方式:
				根据是否为SPJ(选择/投影/连接)查询主要分为两大类，针对SPJ的查询优化以及在SPJ基础上存在Group by、Order By等关键字的复杂查询优化
	
	逻辑查询优化包括的技术:
		子查询优化：
		视图优化：
		等价谓词重写：
		条件化简：
		外连接消除：
		嵌套连接消除：
		连接消除：
		语义优化：
		非SPJ的优化：

3.物理查询优化(Physical Query Optimization):
	物理查询优化主要是基于代价模型进行估算，利用索引进行单表扫描获取元组数据，继而进行两表或多表连接		

=======2.子查询优化====================================================================================
子查询(Subquery):
	当一个查询是另一个查询的子部分时，称之为子查询。子查询可以出现在sql语句中的任何部分。
	子查询语句可以出现在from、where、select、group by和order by中，但后两者中是针对列作处理，虽然可以使用子查询但是没有任何意义。

	子查询的类型(根据不同的分类方式有不同的分类情况)：
		1.从对象间的关系看可分为相关子查询和非相关子查询.
		两者的区别在于子查询中是否含有外层父查询的任何属性值，如有则为相关子查询；没有则为非相关子查询。
	
	在数据库实现早期，查询优化器对子查询一般采用嵌套执行的方式，即对父查询中的每一行，都执行一次子查询，这样子查询会执行很多次。这种执行方式效率很低。
	对子查询进行优化，可能带来几个数量级的查询效率的提高。
	子查询转变为连接操作后，会有如下好处：
		>子查询不必执行很多次
		>优化器可以根据统计信息来选择不同的连接方法和不同的连接顺序。
	
	通常DBMS对子查询常用优化方式：
		1.子查询合并(Subquery CoalAescing)(子查询下推 mysql不支持)
		2.子查询展开(Subquery Unnesting)(子查询反嵌套)
			具体步骤:
				1.将子查询和外层查询的from子句连接为同一个from子句，并且修改相应的运行参数。
				2.将子查询的谓词符号进行相应的修改。
				3.将子查询的where条件作为一个整体与外层查询的where条件合并，并用连接词连接。
		3.聚集子查询消除(Aggregate Subquery Elimination)

	Mysql自动优化的子查询：
		Mysql支持自动优化的子查询情况：
		1.支持简单Select查询中的子查询(SPJ类型的子查询)
		2.支持带有Distinct、Order by、Limit操作的简单Select查询中的子查询。
		Mysql不支持自动优化的子查询情况：
		1.带有Union操作
		2.带有Group by、Having、聚合函数
		3.同时带有Order by和Limit



