
基本概念:

1.CommonJS 规范与实现:
	commonJs是一套规范,nodejs是遵从该规范的一种具体实现
	正如当年为了统一 JavaScript 语言标准,人们制定了 ECMAScript 规范一样,如今为了统一 JavaScript 在浏览器之外的实现,CommonJS 诞生了。CommonJS 试图定义一套普通应用程序使用的API,从而填补 JavaScript 标准库过于简单的不足。CommonJS 的终极目标是制定一个像 C++ 标准库一样的规范,使得基于 CommonJS API 的应用程序可以在不同的环境下运行,就像用 C++ 编写的应用程序可以使用不同的编译器和运行时函数库一样。为了保持中立,CommonJS 不参与标准库实现,其实现交给像 Node.js 之类的项目来完成。

	CommonJS 规范包括了模块(modules)、包(packages)、系统(system)、二进制(binary)、控制台(console)、编码(encodings)、文件系统(filesystems)、套接字(sockets)、单元测试(unit testing)等部分。

2.npm (包管理器):
	Node 包管理器(npm)是一个由 Node.js 官方提供的第三方包管理工具,一个完全由 JavaScript 实现的命令行工具,通过 Node.js 执行
	npm在默认情况下会从http://npmjs.org搜索或下载包
	在使用 npm 安装包的时候,有两种模式: 本地模式和全局模式。默认情况下我们使用 npm本地模式, 全局模式加命令参数npm -g 
	install 命令就是采用本地模式,即把包安装到当前目录的 node_modules 子目录下。

3.n/nvm 多版本管理器
	Node.js 更新速度还很快,有时候新版本还会将旧版本的一些 API 废除,以至于写好的代码不能向下兼容。有时候你可能想要尝试一下新版本有趣的特性,但又想要保持一个相对稳定的环境。基于这种需求,Node.js 的社区开发了多版本管理器,用于在一台机器上维护多个版本的 Node.js 实例,方便按需切换。
	n 是一个十分简洁的 Node 多版本管理器,就连它的名字也不例外。它的名字就是 n

4.supervisor
	Nodejs开发时,无论你修改了代码的哪一部份,都必须终止Node.js 再重新运行才会奏效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件,以后都会直接访问内存,避免重复载入,Node.js的这种设计虽然有利于提高性能,却不利于开发调试
	supervisor 可以帮助你实现这个功能,它会监视你对代码的改动,并自动重启 Node.js。

======================================================================================
Nodejs:
	
	Node.js 适合 I/O 密集型的应用,而不是计算密集型的应用,因为一个 Node.js 进程只有一个线程,因此在任何时刻都只有一个事件在执行。如果这个事件占用大量的 CPU 时间,执行事件循环中的下一个事件就需要等待很久,因此 Node.js 的一个编程原则就是尽量缩短每个事件的执行时间。


	异步式 I/O 与事件式编程:
	
	1.阻塞与线程:
	异步式 I/O (Asynchronous I/O)或非阻塞式 I/O (Non-blocking I/O)则针对所有 I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时,不会以阻塞的方式等待 I/O 操作的完成或数据的返回,而只是将 I/O 请求发送给操作系统,继续执行下一条语句。当操作系统完成 I/O 操作时,以事件的形式通知执行 I/O 操作的线程,线程会在特定时候处理这个事件。为了处理异步 I/O,线程必须有事件循环,不断地检查有没有未处理的事件,依次予以处理。
	阻塞模式下,一个线程只能处理一项任务,要想提高吞吐量必须通过多线程。而非阻塞模式下,一个线程永远在执行计算操作,这个线程所使用的 CPU 核心利用率永远是 100%, I/O 以事件的方式通知。在阻塞模式下,多线程往往能提高系统吞吐量,因为一个线程阻塞时还有其他线程在工作,多线程可以让 CPU 资源不被阻塞中的线程浪费。而在非阻塞模式下,线程不会被 I/O 阻塞,永远在利用 CPU。多线程带来的好处仅仅是在多核 CPU 的情况下利用更多的核,而Node.js的单线程也能带来同样的好处。这就是为什么 Node.js 使用了单线程、非阻塞的事件编程模式。

	单线程事件驱动的异步式 I/O 比传统的多线程阻塞式 I/O 究竟好在哪里呢?简而言之,异步式 I/O 就是少了多线程的开销。对操作系统来说,创建一个线程的代价是十分昂贵的,需要给它分配内存、列入调度,同时在线程切换的时候还要执行内存换页,CPU 的缓存被清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性。

	2.异步IO
	fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统,然后立即返回并执行后面的语句,执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的事件时,事件循环会主动调用回调函数以完成后续工作。

	3.事件
	Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来,事件由 EventEmitter 对象提供。
	Node.js 的事件循环机制:
		Node.js 程序由事件循环开始,到事件循环结束,所有的逻辑都是事件的回调函数,所以 Node.js 始终在事件循环中,程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中,可能会发出 I/O 请求或直接发射(emit)事件,执行完毕后再返回事件循环,事件循环会检查事件队列中有没有未处理的事件,直到程序结束
		Node.js 没有显式的事件循环,类似 Ruby 的 EventMachine::run() 的函数在 Node.js 中是不存在的。 Node.js 的事件循环对开发者不可见
	
	Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.
======================================================================================
Nodejs基础语法:
	
	1.模块和包:
		模块(Module)和包(Package)是 Node.js 最重要的支柱,模块是 Node.js 应用程序的基本组成部分,文件和模块是一一对应的。换言之,一个Node.js 文件就是一个模块,这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展
		node.js 提供了 exports 和 require 两个对象,其中 exports 是模块公开的接口, require 用于从外部获取一个模块的接口,即所获取模块的 exports 对象。
	在浏览器 JavaScript 中,脚本模块的拆分和组合通常使用 HTML 的script 标签来实现。
	2. 单次加载:
		require 不会重复加载模块,引用相同的模块时,后者覆盖前者.	

	包:
		Node.js 的包是一个目录,其中包含一个 JSON 格式的包说明文件,位于项目的顶层目录下 package.json


======================================================================================
常用模块:
	
	1.全局对象与全局变量:
		全局对象:
			JavaScript 中有一个特殊的对象,称为全局对象(Global Object),它及其所有属性都可以在程序的任何地方访问,即全局变量。在浏览器 JavaScript 中,通常 window 是全局对象,而 Node.js 中的全局对象是 global ,所有全局变量(除了 global 本身以外)都是 global对象的属性。
			global 最根本的作用是作为全局变量的宿主。

		全局变量:
			按照 ECMAScript 的定义,满足以下条件的变量是全局变量:
			1.在最外层定义的变量;
				(注意,在 Node.js 中你不可能在最外层定义变量,因为所有用户代码都是属于当前模块的,而模块本身不是最外层上下文。)
			2.全局对象的属性;
			3.隐式定义的变量(未定义直接赋值的变量)
			








======================================================================================
nodejs回调函数:

	Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。回调函数一般作为参数的最后一个参数出现




















