
===========================================结构化并发程序===============================================
6.任务执行：
	大多数并发应用程序都是围绕"任务执行(Task Execution)"来构造的：任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的失误边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
	
	6.1 在线程中执行任务：
		1.单个线程串行执行
		2.为每个任务分配一个线程
	6.2 Executor框架：
		任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。我们已经分析了两种通过线程来执行任务的策略，即把所有任务放在单个线程中串行执行，以及将每个任务放在各自的线程中执行。这两种方式都存在一些严格的限制：串行执行的问题在于其糟糕的响应性和吞吐量，而"为每个任务分配一个线程"的问题在于资源管理的复杂性。
		在java类库中，任务执行的主要抽象对象不是Thread，而是Executor。线程池简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池实现作为Executor框架的一部分。
			public interface Executor {
				void execute(Runnable command);
			}
		虽然Executor是个简单的接口，但它却为灵活且强大的异步任务执行框架提供了基础，该框架支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现类中还提供了对生命周期的支持，以及统计信息手机、应用程序管理机制和性能监视等机制。
		Executor基于生产者――消费者模式，提交任务的操作相当于生产者(生成待完成的工作单元)，执行任务的线程则相当于消费者(执行完这些工作单元)。如果要在程序中实现一个生产者――消费者的设计，那么最简单的方式通常就是使用Executor。
		6.2.1 执行策略：
			通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。包括：
				1.在什么线程中执行任务？
				2.任务按照什么顺序执行(FIFO、LIFO、优先级)?
				3.有多少个任务能并发执行？
				4.在队列中有多少个任务在等待执行？
				5.如果系统由于过载需要拒绝一个任务，那么应该选择哪一个任务？另外如何通知应用程序有任务被拒绝？
				6.在执行一个任务之前或之后，应该进行哪些操作?
		6.2.2 线程池：
			通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上发送竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。
			线程池，从字面含义看，是指管理一组同构工作线程的资源池。线程池是与工作队列(Work Queue)密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程(Worker Thread)的任务很简单，从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
			"在线程池中执行任务"比"为每个任务分配一个线程"优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁规程中产生的巨大开销。类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors的静态工厂方法之一来创建一个线程池:
				newFixedThreadPool:创建一个限制最大长度的线程池，每提交一个任务就创建一个线程，直到达到线程池的最大数量。返回ThreadPoolExecutor实例。
				newCachedThreadPool:创建一个可缓存的线程池，当线程池的当前规模超过了处理需求，将回收空闲的线程; 当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。返回ThreadPoolExecutor实例。
				newSingleTreadExecutor:创建一个单线程的Executor来执行任务。如果这个线程因为异常而结束，会创建另一个线程来代替。它可以通过创建不同的任务队列来确保任务的执行顺序，例如FIFO、LIFO、优先级队列。此外newSingleTreadExecutor还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的，这意味着，即使这个线程会不时地被另一个线程替代，但对象总是可以安全地封闭在"任务线程中"。
				newScheduledThreadPool:创建一个固定长度的线程池，而能够且以延迟或定时的方式来执行任务，类似于Timer
			从"为每个任务分配一个线程"策略编程基于线程池的策略，将对应用程序的稳定性产生重大的影响：web服务器不会再在高负载情况下失败。由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其它功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。
		
		6.2.3 Executor的生命周期
			上面我们谈到如何创建一个Executor，但并没有讨论如何关闭它。Executor的实现通常会创建线程来执行任务。但JVM只有在所有线程(非守护)线程全部终止后才会退出。因此如果无法正确关闭Executor，那么JVM将无法结束。
			为了解决执行服务的生命周期问题，ExecutorService接口对Executor进行了扩展，添加了一些用于生命周期管理的方法(同时还有一些用于任务提交的方法)。
				public interface ExecutorService extends Executor {
					void shutdown();
					list<Runnable> shutdownNow();
					boolean isShutdown();
					boolean isTerminated();
					boolean awaitTermination(long timeout,TimeUnit unit) throws InterruptedException;
				}
			ExecutorService的生命周期有3钟状态: 运行、关闭、已终止。
				ExecutorService在初始创建时处于运行状态。
				shutdown方法将执行平缓的关闭过程，不再接受新的任务，同时等待已经提交的任务执行完成――包括那些还未开始执行的任务。
				shutdownNow方法将执行粗暴的关闭过程，它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。
		6.2.4 延迟任务与周期任务
			Timer类负责管理延迟任务("在100ms后执行该任务")以及周期任务("每10ms执行一次该任务")。然而，Timer存在一些缺陷，因此应该使用ScheduledThreadPoolExecutor来替代它。在jdk5.0以后，将很少使用Timer
			Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其它TimerTask的定时精确性。例如某个周期TimerTask需要每10ms执行一次，而另一个TimerTask需要执行40ms，那么这个周期任务或者在40ms任务执行完成后快速连续地调用4次，或者彻底"丢失"4次调用(取决于是基于固定速率来调度还是基于固定延时来调度)。而线程池能弥补这个缺陷，它可以提供多个线程来执行延时任务和周期任务。
			Timer的另一个问题，如果TimerTask抛出了一个未检查的异常，那么Timer将表现出糟糕的行为。Timer线程并不捕获异常，因此当TimerTask抛出未检查的异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度(线程泄漏[Thread Leakage])。
		6.2.5 DelayQueue
			如果要头肩自己的调度任务，那么可以用DelayQueue，它实现了BlockQueue，并为ScheduledThreadPoolExecutor提供调度功能。DelayQueue管理着一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有当某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据它们的延迟时间进行排序。
	6.3 携带结果的任务Callable与Future：
		Executor框架使用Runnable作为其基本的任务表示形式，因此要使用Executor框架必须将任务描述为一个Runnale。Runnable是一种有很大局限性的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个检查的异常。
		许多任务实际上都是存在延迟的计算――执行数据库查询、从网络上获取资源，或计算某个复杂的功能等。对于这些任务，Callable是一种更好的抽象：它认为主入口点(即call)将返回同一个值，并可能抛出一个异常。在Executor中包含了一些辅助方法能将其它类型的任务封装为一个Callable，例如Runnable和java.security.PrivilegedAction。
		Runnable和Callable描述的都是抽象的计算任务。这些任务通常都是有范围的，即都有一个明确的起始点，并且都会结束等。Executor执行的任务有4个生命周期阶段:创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。
		Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获得任务的结果和取消任务等。
		CompletionService：
			将Executor和BlockingQueue的功能融合在一起，你可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor
			ExecutorCompletionService的实现非常简单。在构造函数中创建一个BlockingQueue来保存计算完成的结果。当计算完成时，调用Future-Task中的done方法。当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，并将结果放入BlockingQueue

7.任务的取消与关闭：
	任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行体质。然而有时候我们希望提前结束任务或线程，或许 因为用户点击了取消操作，或者应用程序需要被快速关闭。
	要使任务和线程安全、快速、可靠地停下来，并不是一件容易的事情。java目前没有提供任何机制来安全地终止线程。但它提供了中断(Interruption)，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。
	这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：当需要停止时，它们首先会清除当前正在执行的任务，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。
	7.1任务取消：
		如果外部代码能在某个操作正常完成之前将其置入"完成"状态，那么这个操作就可以称为可取消(Cancellable)。取消某个操作的原因有很多：
			1.用户请求取消
			2.有时间限制的操作，当计时器超时，需要取消所有正在搜索的任务
			3.应用程序事件，例如应用程序对某个问题空间进行分解并搜索，从而使不同的任务可以搜索问题空间中的不同区域。当其中一个任务找到了解决方案时，所有其它还在进行的任务都应该被取消
			4.错误。例如爬虫任务发生错误时(例如磁盘已满)，那么所有搜索任务都会被取消，此时可能会记录它们的当前状态，以便稍后重新启动。
			5.程序关闭。当一个程序或服务关闭时，必须对正在处理和等待处理的工作执行某种操作。在平缓的关闭过程中，当前正在执行的任务将继续执行直到完成，而在立即关闭过程中，当前的任务则可能被取消
		7.1.1 请求取消标志
			其中一种协作机制能设置某个"已请求取消(Cancellation Request)"标志(必须用volatile修饰)，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。
			另一种协作机制是当逻辑中有sleep等阻塞方法时，将cancel功能写到finally代码块中，以保证线程即使被中断也能调用cancel方法。如果cancel没有被调用，那么处理线程将永远运行下去，不断消耗CPU时钟周期，并使得JVM无法正常退出。
		7.1.2 中断机制：
			通过"请求取消标志"的机制虽然最终会使得任务退出，但在退出的过程中却需要花费一定的时间(轮询该标志所花费的时间)。然而如果使用这种方法的任务调用了一个阻塞方法，例如BlockQueue.put,那么可能产生一个更严重的问题――任务可能永远不会检查取消标志，因此永远不会结束！
			在java的API语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消功能之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前的工作，并转而执行其它的工作。而中断机制是实现任务取消的最合理的方式。
				public class Thread { //线程中的中断方法
					public void interrupt(){}
					public boolean isInterrupted(){}
					public static boolean interrupted(){}
					...
				}
			线程的中断机制改变的是线程中的属性，而阻塞方法(如Thread.sleep、Object.wait)等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，并抛出InterruptedException，表示阻塞操作由于中断而提前结束。虽然JVM并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。
			当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断是否发生了中断。通过这样的方式，中断操作将变得"有粘性"――如果不触发InterruptedException，那么中断状态将一直保持，直到明确地清楚中断状态。
			对中断操作的正确理解是：调用interrupt并不意味着立即停止目标线程正在进行的工作。而只是传递了请求中断的消息，然后由线程自身在下一个合适的时刻中断自己(这些时刻也被称为取消点)。有些方法，例如wait、sleep、join等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其它代码无法对中断请求做出响应。
			在使用static的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，除非你想屏蔽这个中断，否则必须对它进行处理――可以抛出InterruptedException，或者通过再次调用interrupt来恢复中断状态。
		7.1.3 中断策略：
			正如任务中应该包含取消策略一样，线程同样应该包含中断策略。终端策略规定线程如何解释某个中断请求――当发现中断请求时，应该做哪些工作，哪些工作单元对中断来说是原子操作，以及以多块的速度来响应中断。
			最合理的终端策略是某种形式的线程级(Thread-Level)取消操作或服务级(Service-Level)取消操作；尽快退出，在必要时进行清理，并通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务，但对于那些包含非标准中断策略的线程或线程池，只能用于能直到这些策略的任务。
			对于非线程所有者的代码来说，应该小心地保存线程的中断状态，这样拥有线程的代码才能对中断做出响应，即使"非所有者"代码也可以做出响应。这也就是为什么大多数可阻塞的库函数都只是抛出InterruptedException作为中断响应。它们永远不会在某个由自己拥有的线程中运行，因此它们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步操作。
			任务不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中执行，并且在这些服务中包含特定的中断策略。如果除了将InterruptedException传递给调用者外还需要执行其它操作，那么应该在捕获InterruptedException之后恢复中断状态:
				Thread.currentThread().interrupt();
			线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如shutdown方法。由于每个线程拥有各自的终端策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。
			批评者曾嘲笑java的中断功能，因为它 没有提供抢占式中断机制，而且还强迫开发人员必须处理InterruptedException。然而，通过推迟中断请求的处理，开发人员能制定更灵活的中断策略，从而使应用程序在响应性和健壮性之间实现合理的平衡。
		7.1.4 通过Future来实现取消
		
		7.1.5 处理不可中断的阻塞  ？？？？？？？？？？？？？
			许多可阻塞的方法都是通过提前返回或者抛出InterruptedException来响应中断请求的，从而使开发人员更容易构建出能响应取消请求的任务。然而，并非所有的可阻塞方法或者阻塞机制都能响应中断。
			如果一个线程由于执行同步的I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其它任何作用。对于哪些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。
		7.1.6 采用newTaskFor来封装非标准的取消     ？？？？？？？？？？？？？？？？？？
		
	7.2 停止基于线程的服务
	7.3 处理非正常的线程终止
	7.4 JVM关闭
		jvm既可以正常关闭，也可以强行关闭。
		正常关闭的触发方式有多种，包括：最后一个前台线程(非守护线程)结束时；调用了System.exit；
		强行关闭jvm的方式：调用Runtime.halt()；在OS中杀死jvm进程(例如发送sigkill)
		7.4.1 关闭钩子
			在正常关闭中，JVM首先调用所有已注册的关闭钩子(Shutdown Hook)。关闭钩子是指通过Runtime.addShutdownHook() 注册的但尚未开始的线程。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么jvm将运行终结器，然后再停止。jvm并不会停止或中断任何在关闭时仍然运行的应用程序线程。如果关闭钩子或终结器没有执行完成，那么正常关闭进程会"挂起"并且JVM必须强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。

		7.4.2 守护线程 (Daemon Thread)
			有时候我们希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍jvm的关闭。在这种情况下就需要使用守护线程。
			当jvm停止时，所有仍然存在的守护线程都将被抛弃――既不会执行finally代码块，也不会执行回卷栈，而jvm只是直接退出。
			我们应该尽可能少地使用守护线程――很少有操作能够在不进行清理的情况下被安全地抛弃。特别是如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。守护线程最好用于执行"内部"任务，例如周期性地从内存的缓存中移除过期的数据。
		7.4.3 终结器
			当不再需要内存资源时，可以通过GC来回收它们，但对于其它一些资源，例如文件或Socket句柄，当不再需要它们时，必须显式地交给OS。为了实现这个功能，GC对那些定义了finalize方法的对象会进行特殊处理：当回收器释放它们后，调用它们的finalize方法，从而保证一些持久化的资源被释放。
			避免使用终结器

在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加它们在设计和实现时的复杂性。java并没有提供某种抢占式的机制来取消操作或者终结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用FutureTask和Executor框架，可以帮助我们构建可取消的任务和服务。
			
-------------------------------------------------------------------------------------------------------------------
8.线程池的使用	
	第6章介绍了任务执行框架，它不仅能简化任务和线程的生命周期管理，而且还提供一种简单灵活的方式将任务的提交与任务的执行策略解耦开来。
	第7章介绍了实际应用程序中使用任务执行框架时出现的一些与服务生命周期相关的细节问题。
	本章将介绍对线程池进行配置与调优的一些高级选项，并分析在使用任务执行框架时需要注意的各种危险，以及一些使用Executor的高级示例
	
	
			
			
			
			

			
			
			中断代码分析：
				1.interrupt status中断状态中断机制就算围绕着这个字段来工作的。在java源码中代表中断状态的字段是
					private volatile Interruptible blocker;		//初始化为null
				2.调用方法interrupt0(),将导致"该线程中断状态被设置"。
				3.再次调用interrupt0(),将导致"其中断状态被清除"
				


		
