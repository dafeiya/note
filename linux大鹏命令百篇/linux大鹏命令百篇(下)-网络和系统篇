隧道技术是一种"网络协议的数据包被包装在另一种网络协议的数据包之中，以进行数据网络传输"的技术，这种技术其实也是VPN技术的基础和前提

-----------------------------------------------------------------
一.网络操作：
	ping/nslookup/dig/ss/nc/wget/ip
		
	1.ping命令：
		ping命令的核心功能是查看到指定网站的网络连通性和网络延迟，丢包率和请求时间可以反应网络和网卡的状态
		eg:>>ping www.baidu.com
		ping不通网关说明网络配置有问题 ping不通域名说明dns有问题
		ping命令最后一行的mdev指标(Mean Deviation)表示ICMP包的RTT偏离平均值的成都，主要用于衡量网站的稳定性，值越大说明越不稳定
		*TTL:即生存时间，是指数据包被路由器丢弃之前允许通过的路由器最大跳数。TTL是由发生主机来设置的，为了防止数据包在网络中无限循环，每个路由器在转发网络数据包时，都要求将TTL的值减少1，直到TTL减为0的那一刻，这个数据包生命便终结。不同操作系统有不同的默认值
		~~~~~~~~~~~~~~~~~~~~~~~~~~~	
		-t 100 指定最大TTL：ping www.baidu.com -t 100
		-s 640 指定ping包的大小，默认为64字节
		-i 0.2 指定ping的间隔时间，单位s
		-f  使用无间隔的最大的频率发送ICMP包，因此被成为"疯狂模式"，只能root权限使用。

	2.nslookup查询DNS:
		nslookup在bing-utils中，该包还提供了host，dig等网络常用命令。该命令支持交互和非交互两种模式
		eg:>>nslookup www.baidu.com
			Server:		127.0.1.1		//本地/etc/resolv.conf中配置的DNS解析服务器ip
			Address:	127.0.1.1#53	//ip+port

			Non-authoritative answer:	//表示以下结果是从缓存中读取的，非权威的
			www.baidu.com	canonical name = www.a.shifen.com.	//canonical name表示别名
			Name:	www.a.shifen.com	//同一个域名映射了2个ip
			Address: 115.239.211.112
			Name:	www.a.shifen.com
			Address: 115.239.210.27

		*DNS(Domain Name System)，中文名为"域名系统"，主要负责整个互联网中"域名—>ip地址"的映射管理和解析工作。DNS默认端口为53。
		DNS也可以实现"ip->域名"的反解析，域名和ip之间的关系是多对多关系。
		DNS系统采用了一种多级、分层次的组织方案，来实现对域名的管理。DNS的查询方案主要有递归查询、迭代查询以及两者结合的查询方案。在DNS的世界里，没有人知道全部答案，但人们总能告诉你离正确答案最近的下一个高人。
		每一个DNS服务器都由一个高速缓存区，这里面存放着这台DNS服务器最近经手过的"域名->ip地址"映射关系，以及获得这些映射关系的查询出处。例如上连DNS服务器在获得www.baidu.com的ip地址后，就会把这个映射关系缓存到自己机器上，这样做的好处在于:下次再有人询问www.baidu.com的ip后，这台上连DNS服务器就不需要再发起查询了，直接就可以从缓存中找到答案。但是实际情况下网站的ip是可能改变的(例如网站迁移或容灾)，缓存中的DNS可能是"失效"的，所以如果DNS服务器是从缓存中获取的ip映射，那么就会很谨慎地在返回的内容中给出'Non-authoritative answer'非权威的字样，目的是提示用户，虽然域名对应的ip已经查到，但它是缓存中拿取的，并不保证是最新的。只有当DNS解析信息是从管理该域名的DNS服务器上返回时，结果才是'authoritative'权威的
		*DNS的五元组：{DomainName,TimeToLive,Class,Type,Value}
		一提到DNS,大家都会直观地认为DNS就是用来做域名和ip地址转换的，但事实并非如此，准确说，DNS是用来做域名和资源转换的，二ip地址只是资源中的一种而已。DNS查询返回的其实是与域名相关的资源记录，在DNS的世界里，资源是一个五元组。
			1.DomainName(域名)：
			2.TimeToLive(生存期限):表示此域名在各DNS服务器缓存中应保存的时长。
			3.Class(类别):通常为IN,即Internet。
			4.Type(类型): 指出这条记录的类型，有8种
			*	4.1: SOA  域名的最基础的信息，比如版本序号、更新频率、缓存域名的失效时间、TTL(数值越小，修改记录各地生效时间越快)
			*	4.2: A    表示从域名解析到的ip地址，俗称"A记录"。为默认的查询类型
				4.3: MX   表示当前域名对应的邮箱服务器。
			*	4.4: NS    Name Server    即DNS的NS记录,用来做向下授权的,指定域名将由哪个子DNS服务器来进行解析。
				4.5: CNAME 表示域名的别名
			*	4.6: PTR  即指针，用于反解析信息，即从ip地址查询其对应域名的映射关系
				4.7: HINFO 包含CPU和OS等信息
				4.8: TXT  
			5.Value(值，根据不同的type会有不同的值)
		Google对外发布了DNS解析服务，首选DNS服务器是8.8.8.8，备选DNS服务器是8.8.4.4
		nslookup会连接到默认的域名服务器，即/etc/resolv.conf中所配置的第一个DNS服务器的地址。当然也支持在命令行中指定要连接的DNS服务器。
		~~~~~~~~~~~~~~~~~~~~~~~~~~~
		非交互模式下
		- 8.8.8.8  指定解析域名的DNS服务器
		-type=soa  指定域名的查询类型以获得指定的信息
		nslookup 8.8.8.8   根据ip反解析域名
		交互模式下
		set all    查看nslookup常用选项的当前设置值
		set debug  进入调试模式，该模式下域名查询过程中完整交互包都会显示出来
		set querytype=soa   设置查询类型

	3.dig简化DNS查询
		相对于nslookup，dig命令设置灵活、输出清晰、功能更强大
		eg: dig @8.8.8.8 www.baidu.com   //使用google的DNS解析百度域名
			
		全球13组根域名服务器以英文字母A到M依序命名，域名格式为“字母.root-servers.net”。全部已以任播技术在全球多个地点设立镜像站
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		直接dig命令，不加任何选项时，dig会上连DNS服务器查询"."(跟域)的NS记录
		-t soa   设置查询类型
		-x ip    反解析，通过ip查询域名
		+tcp     使用tcp请求查询DNS信息，默认为udp方式
		+trace	 打印出DNS查询中的所有请求和响应
		+short   精简输出，只输出CNAME和A信息

	4.ss操作socket链接
		ss命令(Socket Statistics)在iproute2软件包中，这是一套支持ipv4/6的用于管理tcp/udp/ip网络的软件包，主要用于网络配置和流量控制方面，已经全面替代net-tools。它所包括的主要工具有:
			~ip:管理路由、设备、策略和隧道
			~ss:管理OS socket相关信息
			~tc:管理流量控制策略
			~nstat:用于网络统计
			~bridge:管理桥接地址和设备
			~ifcfg:进行ip管理，以替代ifconfig
			~instat:展示网络状态
		ss用于获取Socket统计信息，它比netstat更加快速高效。这是因为ss利用了tcp协议栈中的tcp_diag模块(用于分析统计用)，可以获得linux内核中的第一手信息，因此保证了ss的高效
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		ss -s	查看当前服务器的网络连接的统计信息
		-l		查看当前所有打开的网络端口
		-p		在输出中列出具体的程序名称
		-a		列出所有的网络连接
		-ta		列出所有tcp链接
		-ua		列出所有udp连接
		-wa		列出所有raw连接(原始套接字（raw socket）是一种网络套接字，允许直接发送/接收IP协议数据包而不需要任何传输层协议格式)
		-xa		列出所有unix连接(Unix domain socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信)

	5.管理网络的ip命令：
		和磁盘设备类似，Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，既通用的 Linux 网络设备来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它。更多的硬件会带来更多的设备实例，虚拟的硬件也会带来更多的设备实例。随着网络技术，虚拟化技术的发展，更多的高级网络设备被加入了到了 Linux 中，使得情况变得更加复杂。经常使用的几种 Linux 网络设备抽象类型有：Bridge、802.1.q VLAN device、VETH、TAP等。
		ip命令可用于管理网络链路(link)、ip地址(addr)、路由/网关(route、rule)、arp表(neigh)、隧道(tunnel)、组播(maddr)
		5.1 ip addr 操作ip地址
			ip addr show  查看网络接口信息(show/list等效)
				返回信息说明：
					lo			  	回环网卡(loopback)设备号    不走物理层
					enp0s31f6/eth0  网卡设备号				    物理层Ethernet 
					wlp3s0			无线网卡设备号				物理层IEEE 802
					//ether 以太网
			ip addr add 192.168.1.111/24 dev wlp3s0   为某个网络接口添加ip地址
			ip addr del 192.168.1.111/24 dev wlp3s0   删除某个网络接口的ip地址
			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			-6	   展示ipv6地址信息

		5.2 ip link 操作网络接口
			ip link set enp0s31f6 down	禁用(down)/开启(up)网络接口
				在系统网络运维过程中，我们有时需要将一个网卡状态置为禁用状态，以便对系统进行排错或者对网卡进行维修，这时就用到ip link 命令来控制网卡的禁用和激活了。
			ip -s -h addr ls wlp3s0     查看指定网卡的收发包情况
		
		5.3 ip route 操作路由
			ip route show    查看路由表
				default via 192.168.18.1 dev wlp3s0  proto static  metric 600 
				169.254.0.0/16 dev wlp3s0  scope link  metric 1000 
				192.168.18.0/24 dev wlp3s0  proto kernel  scope link  src 192.168.18.106  metric 600	
				//proto:该条路由规则的创建方式，kernel为内核自动创建
				//scope:路由规则的连接方式，link表示直连
				//metric：设置的路由跳数

			ip route add default via 192.168.1.6  添加一条指定默认网关的路由规则
			默认网关的作用就是一台主机如果找不到匹配的转发规则，那么就把数据包转发给默认指定的网管，由这个网关来处理数据包。默认网关一定要指定正确，否则就会造成本机网络连通方面的问题。		

			ip rule 操作基于策略的路由	
			ip rule show   查看策略路由表(以下3条为系统默认的路由规则)
				0:	from all lookup local		//系统默认的local路由规则
				32766:	from all lookup main	//系统默认的main路由规则
				32767:	from all lookup default //系统默认的default路由规则
						
		5.4 ip neigh 操作arp表，用于进行ip和mac地址的翻译工作(ip neighbour等同)
			ip neigh show   查看arp表
				arp表是动态变化的，列表的每一行有个字段表示该设备的状态
					STABLE:邻居存在，但目前处于不可到达状态
					DELAY: 探测邻居到达与否的数据包已经发出，正在等待邻居的回复
					REACHABLE:邻居存在，而且是可达的

			ip neigh add 192.168.6.4 lladdr aa:bb:cc:dd:ee:ff dev eth0 nud permanent  
			在设备eth0上为neighbour 192.168.6.4添加永久ARP条目
			ip neigh del 192.168.6.4 dev eth1   删除设备eth1 neighbour 192.168.6.4的ARP条目

		5.5 ip maddr 操作组播，组播地址必须是D类ip，范围是从224.0.0.0到239.255.255.255。d类地址不能出现在ip报文的源ip地址字段。
			以太网传输单播ip报文的时候，目的mac地址使用的是接收者的mac地址。但是在传输组播报文时，传输目的不再是一个具体的接收者，而是一个成员不确 定的组，所以使用的是组播mac地址。组播mac地址是和组播ip地址对应的。
			ip maddr show   显示网络接口的组播信息
				224.0.0.1 所有主机的地址
			　　224.0.0.2 所有组播路由器的地址

	6. Ipv6
		为了解决ipv4资源枯竭，ipv6被提出
		ipv6的优势：
			1.超大的地址空间，达到128bit，是ipv4的4倍。地址空间比32bit的ipv4的增大了296倍，多到可以让地球上每一粒沙子拥有一个ip地址
			2.ipv6有更加灵活的可选的扩展首部，而且由于路由器不需要处理扩展的首部，所以同事提升了路由器的处理效率
			3.ipv6允许协议的二次扩充
		ipv6的规范:
			1.由于地址太长，采用"冒号16进制"来呈现ipv6地址而非十进制。例如fe80::215a:918a:2f87:6ba0/64。
			2.0省略，如果某一组是000c,则可以直接写成c。
			3.0压缩，如果一个地址是fe04:0:0:0:0:0:0:b2，那么可以直接写成fe04::b2。一个ipv6地址中0压缩只能使用一次
			4.兼容ipv4，4/6混写。ipv4向ipv6转化时，完全可以写成0:0:0:0:0:0:128.10.4.4,然后再使用0压缩就变成了::128.10.4.4

		网络的传输：
			1.单播(unicast): 
			主要的实现:tcp，udp
			是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。每次只有两个实体相互通信，发送端和接收端都是唯一确定的。你对小月月喊“小月月”，那么只有小月月回过头来答应你。
			2.组播(multicast):
			主要的实现:udp(MulticastSocket对象) 
			也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。IP组播是一种通过使用一个组播地址将数据在同一时间以高效的方式发往处于TCP/IP网络上的多个接收者的协议。此外，它还常用来与RTP等音视频协议相结合。你在大街上大喊一声“美女”， 会有一群女性回头看你。
			组播必须使用特殊的D类ip
			3.广播(broadcast):udp(使用广播地址)
			是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。并非所有的计算机网络都支持广播，通常，广播都是限制在局域网中的，比如以太网或令牌环网络。因为广播在局域网中造成的影响远比在广域网中小得多。
			在Java中，在Java UDP中单播与广播的代码是相同的,要实现具有广播功能的程序只需要使用广播地址即可。
			4.任播(anycast):
			是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。

	7. nc,一只胜任全天下tcp/udp一切操作的"网猫", nc是基于C/S的。
		7.1 建立聊天室：
			nc -l 8888		  创建一个服务器端监听服务
			nc 127.0.0.1 8888 创建一个客户端连接服务端	
			连接建立后，在任何一端的输入的文字都将出现在另一端，使用C-d将断开连接。

		7.2 扫描端口：
			nc -zvn -w 2 127.0.0.1 20-700	扫描本机20-700的端口
			经测试，631端口(打印机程序端口)开发，

		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		-l port		监听指定端口等待其它客户端的连接
		-z			一旦建立连接成功马上断开，且不发送或接受任何数据
		-v			打印输出信息
		-n			直接使用ip地址
		-w			设置连接的超时时间，单位秒
		-u			使用udp连接，默认为tcp

	8. wget 非交互式的网络下载器
		wget的主要特性:
			1.wget支持http，https，ftp协议的下载，其中也包括通过http代理的下载。
			2.wget能够跟踪html和xhtml文件，从而使得你可以下载整个站点的文件，然后离线阅读。但要注意因为几乎站点通常都会有外链，一旦用wget进行整站下载，它也会傻傻地去下载外链站点的内容。
			3.wget是个非常遵守Robot Exclusion Standard(robots.txt)标准的工具，但也支持躲避robots封禁。
			4.wget支持失败重试和断点续传功能。
		wget配置文件/etc/wgetrc

		使用示例：	
			1.下载某个目录下面的所有文件：
				wget -c -r -np -k -L -p www.xxx.org/pub/path/
			2.在下载时。有用到外部域名的图片或连接。如果需要同时下载就要用-H参数。
				wget -np -nH -r --span-hosts www.xxx.org/pub/path/

			3.下载整个站点的所有文件:
				wget --mirror --convert-links --page-requisites --no-parent www.baidu.com
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			-c 断点续传
			-p (page-requisites) 下载网页所需的所有文件，如图片等
			-r 递归下载，下载指定网页某一目录下（包括子目录）的所有文件
			-nd 递归下载时不创建一层一层的目录，把所有的文件下载到当前目录,让所有下载的文件平铺到一个文件中
			-np 递归下载时不搜索上层目录，如wget -c -r www.xxx.org/pub/path/没有加参数-np，就会同时下载path的上一级目录pub下的其它文件，文件下载时不追溯至父目录
			-x  下载时强制创建目录，即使原文件没有文件夹也会创建目录
			-P ./save    (directory-prefix=前缀)     保存文件到 <前缀>/..
			-k	(convert-links)将静态文件中的绝对链接转为相对链接，下载整个站点后脱机浏览网页
			-L 递归时不进入其它主机，如wget -c -r www.xxx.org/ 如果网站内有一个这样的链接： www.yyy.org，不加参数-L，就会像大火烧山一样，会递归下载www.yyy.org网站
			-O savefile	 (output-document=文件)      将文档写入 FILE
			-R png,js	 (reject=列表)               逗号分隔的要拒绝的扩展名列表,下载时跳过指定格式的文件
			-A html,xhtml		 只下载指定格式的文件
			--execute robots=off	避开robots.txt的封禁
			–user-agent   设置伪装的代理，wget –user-agent=”Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16″ 下载链接 
			-o logfile       将日志保存到指定文件
			-proxy=on		 利用代理服务器进行下载。此时需要在当前用户的目录下创建一个.wgetrc文件。文件中可以设置代理服务器： http-proxy = 111.111.111.111:8080 ftp-proxy = 111.111.111.111:8080 分别表示http的代理服务器和ftp的代理服务器。如果代理服务器需要密码则使用： –proxy-user=USER设置代理用户 –proxy-passwd=PASS设置代理密码 


===================================================================================================================================
二.进程和性能分析：
	uptime/free/vmstat/mpstat/iostat/top

	1.uptime查看开机时长和CPU负载情况
		eg: uptime
			19:50:27 up  5:35,		1 user,			load average: 0.30, 0.28, 0.20
			(currtime)   (runtime)	(connectNum)    (系统平均负载，统计最近1/5/15分钟的系统平均负载)
		平均负载：指在特定时间间隔内运行队列中的平均进程数。0.00表示CPU空载；1.00表示满载；>1.00表示过载。按一般经验来看，单核负载<0.7是安全的，超过0.7就需要优化了。注意，对于CPU来说负载为1仍然是安全的
		/proc/loadavg 文件中存放着负载信息。/proc中的绝大部分内容是linux内核来控制和更新的
	
	2.内存不决问free
		eg: free -h
						  total        used        free      shared		buff/cache   available
			Mem:           7.5G        1.6G        3.5G        488M        2.4G        5.5G
			Swap:           13G          0B         13G
		
		目前消费级市场最快的DDR4内存，读写速度大概在60GB/s的量级，而目前最快的SSD固态硬盘的读写速度也仅仅是600MB/s，两者存在着100倍的速度差
		buffer是块设备I/O相关的缓存页，用于积累一定的数据量后成批次地进行I/O以避免少量多次的I/O
		cached是普通文件相关的缓存页，为了实现该数据的重用
		关于swap分区，swap分区是一块硬盘分区，当内存空间不足时，会将一些"暂时不用"的进程转到swap中，使用时再读取到内存中。而"内存不足"的影响因素是由一个swappiness参数(/proc/sys/vm/swappiness)来觉定的，OS根据该参数来决定对swap分区操作的"积极性"
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		-b/-k/-m/-g		按照字节/kB/MB/GB/取整计算大小

	3.vmstat一个强大的性能监控利器
		vmstat可以用来查看slab信息、磁盘I/O、分区I/O，以及内存/系统事件信息等。
		eg: vmstat 1 3 -S M
		procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
		 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
		 1  0      0   3491    125   2334    0    0     4    16  111   65  3  1 95  0  0
		 0  0      0   3489    125   2336    0    0     0     0  314  835  0  0 99  0  0
		 0  0      0   3489    125   2336    0    0     0     0  309  814  0  0 99  0  0
		注意，第一行输出的是自服务器启动至今的各项指标的平均值，而非最新状态，从第二行开始才能反应服务器当前最新状态
		*如果cache的数值较大，则说明系统缓存了较多的磁盘数据，利于磁盘I/O性能的提升。这个时候，往往bi会相对较小，因为很多读磁盘的操作都由cache来承担了。
		*si和so是读写swap的量，这两个值如果长期大于0，则表示系统需要经常读写交换分区，这会很消耗CPU资源和磁盘I/O性能。这时就要格外关注了，如果确定是系统的物理内存存在瓶颈，那么就要通过扩容或服务迁移来解决问题。
		*如果free的数值很低，甚至接近0，也不一定是系统内存快耗尽了，要同时看buff和cache的量，大部分情况是buff和cache占用了很多内存资源，这反而是好事，说明系统把空闲的内存都利用起来作为缓存，提升系统I/O性能了。而当系统真正需要内存时，buff和cache是可以随时被系统征调回来的。
		*如果发现bi和bo的值很大，则说明系统正在进行大量的磁盘读写操作。如果是符合预期的还好，如果不是的话，需要查一下到底是哪块磁盘，哪个分区在进行大量读写。
		*如果us的数值经常大于50%，则说明用户进程所占用的CPU时间较多，这或许说明所开发的程序需要进行一定程度的性能优化了。
		*sy是内核所消耗的CPU时间，这个数值不应该很高。如果很高，则一定是系统哪里出了问题
		*如果wa很高，则说明CPU总是在等待I/O操作，这说明磁盘已经成为主要瓶颈，我们可以把磁盘升级为高性能磁盘，也可以查一下我们的程序是不是存在大量的随机读操作，如果是的话，可以考虑调整为顺序读或者考虑增加读缓存。
		*r表示的是正在运行队列中的任务数，如果这个数值总是超过服务器CPU的核数，则说明CPU已经成为性能瓶颈，可以考虑开启超线程、更换更多核的CPU、调整某些进程的NICE优先级等措施
		*如果你正在运行一个视频编解码的任务，那么us的数值可能会很高，甚至高达95%以上，这是符合预期的，不要紧张。如果你要运行一个能产生大量随机数的程序，或者其它包含系统调用的程序，那么sy可能会非常高，这也很正常。
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		-s	显示内存指标及系统事件信息
		-d	显示磁盘的统计信息

	4.mpstat,了解CPU的心
		mpstat用于多处理器信息的统计工作。
		mpstat -P ALL	查看当前电脑所有CPU的情况
			Linux 4.15.0-43-generic (limeng-ThinkPad-T470p)		2019年03月11日	_x86_64_	(8 CPU)

			21时52分55秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
			21时52分55秒  all    8.63    0.01    2.16    0.95    0.00    0.10    0.00    0.00    0.00   88.15
			21时52分55秒    0    8.98    0.01    1.37    0.35    0.00    0.38    0.00    0.00    0.00   88.90
			21时52分55秒    1    9.39    0.03    6.95    3.18    0.00    0.10    0.00    0.00    0.00   80.35
			21时52分55秒    2    8.79    0.01    1.86    1.31    0.00    0.14    0.00    0.00    0.00   87.89
			21时52分55秒    3    7.97    0.01    1.67    0.92    0.00    0.07    0.00    0.00    0.00   89.35
			21时52分55秒    4    8.65    0.01    1.39    0.54    0.00    0.03    0.00    0.00    0.00   89.37
			21时52分55秒    5    8.29    0.01    1.32    0.50    0.00    0.04    0.00    0.00    0.00   89.85
			21时52分55秒    6    8.40    0.00    1.29    0.38    0.00    0.03    0.00    0.00    0.00   89.89
			21时52分55秒    7    8.57    0.01    1.41    0.40    0.00    0.02    0.00    0.00    0.00   89.58
		%usr:	用户进程所使用CPU的占比
		%nice:	对进程进行降级的CPU占比
		%sys:	内核进程使用的CPU占比
		%iowait:等待进行I/O所使用的CPU时间占比
		%irq:	等待系统中断的CPU占比
		%soft:	软件中断的CPU占比
		%steal:	虚机管理程序占用的CPU占比
		%guest:	运行虚拟处理器占用的CPU占比
		%idle:	CPU的空闲时间
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 mpstat -I SUM   查看系统的所有的CPU中断总和

		vmstat -f 查看系统的forks，forks是由fork、vfork和clone三类系统调用所产生的，可以理解为是系统创建的总任务数(tasks)。一个进程可以创建一个或多个任务(tasks),而具体包括多少任务，则取决于此进程中创建了多少个线程。

	5.top实时更新的性能监控利器
		top命令的输出信息较为复杂，且是周期性刷新的。top的输出主要分为两部分：上部分为系统级数据，如系统负载信息、CPU信息、内存信息等；下部分为进程级数据，包含每一个进程的详细信息，如PID,User,Command等.
		单击快捷键 f ，会进入进程信息的列选择页面，我们可以根据操作提示进行添加/删除所需列。使用左/右键用于释放/选定指定列后，再使用上下键可以移动列，用以控制列的显示位置。以上所做的设置只在当前bash中有效，如过想永久保存，可以使用快捷键 W ,该快捷键会把top当前的配置保存到~/.toprc文件中去。
		1.进程所处的状态说明：
			R-运行		S-睡眠		D-不可中断的睡眠状态		T-跟踪、停止		Z-僵尸

		2.top中的常用快捷键：
			u:  显示指定用户下的进程信息
			s:	设置更新时间(默认3秒)
			k:	kill，输入进程号杀进程
			c:	显示具体的cmd
			b:	处于运行(R)状态的进程会高亮显示
			d:	设置数据刷新的间隔秒数，默认为3s
			m：	使用图示显示memery和swap的信息
			1:	(数字1)，显示CPU的运行数据	
			0:	(数字0)，只显示有效的%CPU

	6.iostat让I/O尽在掌握中
		iostat，用来显示CPU的统计信息以及整个系统、适配器、tty设备和硬盘的所有I/O信息
		eg: iostat
			Linux 4.15.0-43-generic (limeng-ThinkPad-T470p)		2019年03月13日	_x86_64_(8 CPU)		//OS信息

			avg-cpu:  %user   %nice %system %iowait  %steal   %idle									//CPU信息
			           2.62    0.00    0.99    0.89    0.00   95.50

					   Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn		//磁盘信息
					   sda              10.24       165.77       153.56    1062039     983813
					   mmcblk0           0.03         0.82         0.00       5280          0
					   dm-0              0.02         0.51         0.00       3240          4

			磁盘信息中展示了服务器上各个存储设备的I/O情况，包括块的读写量和读写速度等
			输出说明：
				1.tps			每秒进程的I/O读写请求总数
				2.KB_read/s		每秒读取的字节数(KB)
				3.KB_wrtn/s		每秒写入的字节数(KB)
				4.KB_read		读取的字节总数(KB)
				5.KB_wrtn		写入的字节总数(KB)
			注意，iostat输出的磁盘信息中第一组数据是有特殊意义的，它表示从linux系统启动至本命令执行这段时间的统计结果，而后面的数据都表示iostat执行一个采样周期(默认1s)的统计结果。由此，第一组数据外的其它数据才是实时、有效的，最能反应最近磁盘I/O情况的。
			
		eg: iostat -x -y -d 1 1
			Linux 4.15.0-43-generic (limeng-ThinkPad-T470p)		2019年03月18日	_x86_64_	(8 CPU)
			Device:    rrqm/s   wrqm/s    r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
			sda        0.00    31.00   339.00    2.00  4720.00   132.00    28.46     0.95    2.80    2.58   40.00   2.03  69.20
			mmcblk0    0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00
			dm-0       0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00
			输出说明：
				1.rrqm/s	文件系统每秒对读取同块(block)请求的合并次数
				2.wrqm/s	文件系统每秒对写入同块(block)请求的合并次数
				3.r/s		每秒完成读I/O的次数
				4.w/s		每秒完成写I/O的次数
				5.rkB/s		每秒读千字节数
				6.wkB/s		每秒写千字节数
				7.avgrq-sz	平均每次I/O操作的数据大写，即(rsec/s+wsec/s)/(r/s+w/s)
				8.avgqu-sz	平均等待处理的I/O请求队列长度
				9.await		平均每次I/O请求等待时间(包括等待时间和处理时间，单位ms)，可以理解为I/O的响应时间。一般系统的响应时间应该低于5ms，如果大于10ms就比较大了。
				10.r_await
				11.w_await
				12.svctm	平均每次I/O操作的服务时间，单位ms
				13.%util	周期内用于I/O操作的时间比率
		
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		-d		只显示磁盘信息
		-c		只显示CPU的信息
		-k		以kb为单位
		-x		展示更加详细的硬盘I/O信息
			
	7. lsof监测一切文件
		lsof用来查看进程打开的文件、目录和套接字等一切信息，是linux系统管理员经常使用的工具之一。
		lsof命令原理：在linux系统中，为了方便管理进程，会在/proc下为每一个运行中的进程创建一个目录，目录名就是进程号，而在进程的目录下有一个叫fd的目录，这个目录下存放的是进程打开的所有文件。而lsof命令搜索的其实就是/proc/$PID/fd下面的文件。


		不带任何参数时输出当前系统中所有正被进程打开的文件信息
		eg:sudo lsof -p 80
			  lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/1000/gvfs
				  Output information may be incomplete.
			  COMMAND   PID USER   FD      TYPE DEVICE SIZE/OFF NODE NAME
			  watchdogd  80 root  cwd       DIR    8,9     4096    2 /
			  watchdogd  80 root  rtd       DIR    8,9     4096    2 /
			  watchdogd  80 root  txt   unknown                      /proc/80/exe
		输出说明：
			FD:		一般指文件描述符。但却可以指代两类内容，一类是文件描述符；另一类是描述文件特征的标识。
				文件描述符：(文件描述符后面还可以跟文件状态模式和文件锁)
					0	表示标准输入
					1	表示标准输出
					2	表示标准错误输出
					n	表示其它文件描述符的数值
				文件特征的标识：
					cwd		应用程序的当前工作目录，也是该应用程序启动的目录
					txt		该类型文件是程序代码或数据
					mem		内存映射文件
					pd		父目录
					rtd		根目录
					DEL		表示文件已经被进程删除了但还在内存中存在

			TYPE:	文件类型，如DIR(目录)、REG(普通文件)，常见的文件类型如下：
				（1）DIR：表示目录
				（2）CHR：表示字符类型
				（3）BLK：块设备类型
				（4）UNIX： UNIX 域套接字
				（5）FIFO：先进先出 (FIFO) 队列
				（6）IPv4：网际协议 (IP) 套接字
			DEVICE：指定磁盘的名称
			SIZE：	文件的大小
			NODE：	索引节点（文件在磁盘上的标识）
			NAME：	打开文件的确切名称
			
				
		通过文件定位进程(直接跟文件名)	
			sudo lsof openfile.txt	查看正在操作openfile.txt文件的进程
		
		通过进程定位文件
			sudo lsof -p 80		查看使用80端口的进程所操作的文件
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~			
			-u limeng	查看指定用户下的所有进程所操作的文件

	8. 符合posix标准的fuser
		上述的lsof虽然功能强大，但遗憾的是lsof并不是posix标准中规定的命令，因此在可移植性方面会稍微差点。而经常用于和lsof比较的fuser命令则属于posix标准的命令集。
		*POSIX (Portable Operating System Interface) 中文称为可移植操作系统接口。
		posix是一种有关OS的行业标准，该标准的职责是确保程序在源码级别上可移植性。通俗地说，只要在程序开发过程中使用的是posix标准规定的api和命令，那么这个程序就应该可以在任何其它符合posix标准的OS上编译和执行。而linux完全遵循posix标准
































