主要命令行：
	1.配置用户信息：
		git config --global user.name limeng
		git config --global user.email limeng@123.com
			设置为全局配置，任何一个新建的git项目默认都采用这些信息。如果去掉--global选项，则设定只保存在当前项目的 .git/config文件里
			这样每次提交时git都会引用这两条信息，每次git变动都会记录是谁的操作
		$ git config user.name limeng
		$ git config user.email limeng@123.com
			仅设置当前仓库的配置
			
		git config --list	#查看已有配置信息
		
	2.git仓库管理：
		git init	#将当前文件创建为git仓库 
			初始化后,在当前目录下会出现一个名为 .git 的目录,所有 Git 需要的数据和资源都存放在这个目录中。
		git clone https://github.com/dafeiya/dafeiya.github.io.git dafeiya	#克隆仓库，并指定仓库名称。git会自动创建文件并初始化仓库
			默认情况下git clone命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的master 分支
		.gitignore		#指定忽略的文件
		git add file	#将指定文件纳入git版本控制
		git commit		#将add已纳入的文件变更提交
			提交时记录的是放在暂存区域的快照，每一次运行提交操作,都是对你项目作一次快照,以后可以回到这个状态,或者进行比较。每一次commit都会进行一次完整 SHA-1 校验(SHA-1码 463dc4f )作为此次提交的序列号
			添加 -a 参数可以跳过git add命令
			-m参数可以覆盖上一次提交的日志
			
		git status		#检查当前仓库的文件状态
		git rm			#移除文件
			要从 Git 中移除某个文件,就必须要从已跟踪文件清单中移除(确切地说,是从暂存区域移除),然后提交。可以用命令完成此项工作,并连带从工作目录中删除指定的文件,这样以后就不会出现在未跟踪git rm文件清单中了。
		git log			#查看提交历史
		git reflog		#查看简化版的命令操作历史


	3.git远程仓库:
		git remote -v	#看当前配置有哪些远程仓库
		git remote add [shortname] [url]	#添加一个新的远程仓库,并指定一个简单的名字,以便将来引用
			git remote add dafeiya2 https://github.com/dafeiya/dafeiya2.github.io.git
		git fetch [remote-name]	#从远程仓库抓取数据
			git fetch dafeiya2
			此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后,你就可以在本地访问该远程仓库中的所有分支,将其中某个分支合并到本地,或者只是取出某个分支,一探究竟
			如果是克隆了一个仓库,此命令会自动将远程仓库归于 origin 简称名下。所以, git fetch origin会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新(或是上次 fetch 以来别人提交的更新)。有一点很重要,需要记住,fetch 命令只是将远端的数据拉到本地仓库,并不自动合并到当前工作分支,只有当你确实准备好了,才能手工合并。

		git pull [remote-name] #从远程仓库抓取数据并自动合并到当前仓库的主分支
		git push [remote-name] [branch-name]	#推送数据到远程仓库
			如果在你推数据前,已经有其他人推送了若干更新,那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地,并到自己的项目中,然后才可以再次推送。
		git remote show [remote-name]	#查看远程仓库信息
	
	4.打标签tag:
		Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本(比如 v1.0等等)的时候,经常这么做。

	5.分支操作：
		git branch [branch-name]	#创建新的分支
			git branch -d tempbranch	#删除分支
			git branch --merge		#查看哪些分支已经并入到当前的分支
		git checkout [branch-name]	#将HEAD指针切换到指定的分支。branch创建分支时不会自动切换到这个分支中去
			HEAD指针 会在一次 checkout 之后指向另一个分支
			注意，切换分支时，Git 会把工作目录的内容恢复为检出某分支时它所指向的那个 commit 的快照。它会自动添加、删除和修改文件以确保目录的内容和你上次提交时完全一样
			git checkout -b iss53	相当于git branch iss53 加git checkout iss53
			checkout -b [分支名] [远程名]/[分支名]	#检出远程仓库的指定分支内容到本地的指定分支
		git merge hotfix	#将hotfix分支合并到当前正在操作的分支上	

		git push origin serverfix	#推送分支到远程
			Git 自动把serverfix分支名扩展为refs/heads/serverfix:refs/heads/serverfix ,意为“取出我的 serverfix 本地分支,推送它来更新远程仓库的 serverfix 分支”。
			也可以运行git push origin serverfix:serferfix来实现相同的效果
			git push origin :serverfix	#删除远程的serverfix分支，省略[本地分支] ,那就等于是在说“在这里提取空白然后把它变成 [远程分支] ”
	6.回退：
		git reset –hard origin/master  #将本地的状态回退到和远程的一样 










~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1.Git简介：
	直接快照,而非比较差异：
		Git 和其他版本控制系统的主要差别在于,Git 只关心文件数据的整体是否发生变化,而大多数其他系统则只关心文件内容的具体差异。这类系统(CVS,Subversion,Perforce,Bazaar 等等)每次记录有哪些文件作了更新,以及都更新了哪些行的什么内容
		Git 并不保存这些前后变化的差异数据。实际上,Git 更像是把变化的文件作快照后,记录在一个微型的文件系统中。每次提交更新时,它会纵览一遍所有文件的指纹信息并对文件作一快照,然后保存一个指向这次快照的索引。为提高性能,若文件没有变化,Git 不会再次保存,而只对上次保存的快照作一连接。



2.文件状态：
	已提交(committed):已提交表示该文件已经被安全地保存在本地数据库中了
	已修改(modified):已修改表示修改了某个文件,但还没有提交保存
	已暂存(staged)。已暂存表示把已修改的文件放在下次提交时要保存的清单中。

	Git 管理项目时,文件流转的三个工作区域:
		Git 的本地数据目录:.git/ 目录
		工作目录:从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录
		暂存区域:所谓的暂存区域只不过是个简单的文件,一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件,不过标准说法还是叫暂存区域
	
		HEAD:
			这是当前分支版本顶端的别名，也就是在当前分支你最后的一个提交。
		Index 暂缓区:
			index也被称为staging area，是指一整套即将被下一个提交的文件集合。他也是将成为HEAD的父亲的那个commit
			index就是git add 命令后得到的暂存区的标记综合。
		Working Copy 工作区:
			working copy代表你正在工作的那个文件集


	工作目录下面的所有文件都不外乎这两种状态:已跟踪(tracked)或未跟踪(untracked)。
	已跟踪的文件是指本来就被纳入版本控制管理的文件,在上次快照中有它们的记录,工作一段时间后,它们的状态可能是未更新(unmodified),已修改(modified)或者已放入暂存区(staged)。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照,也不在当前的暂存区域。初次克隆某个仓库时,工作目录中的所有文件都属于已跟踪文件,且状态为未修改。

3.Git分支：
	几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来,然后在不影响主线的同时继续工作。在很多版本控制系统中,这是个昂贵的过程,常常需要创建一个源代码目录的完整副本,对大型项目来说会花费很长时间。Git 的分支可谓是难以置信的轻量级,它的新建操作几乎可以在瞬间完成,并且在不同分支间切换起来也差不多一样快。
	Git 保存的不是文件差异或者变化量,而只是一系列文件快照。
	在 Git 中提交时,会保存一个提交(commit)对象,它包含一个指向暂存内容快照的指针,作者和相关附属信息,以及一定数量(也可能没有)指向该提交对象直接祖先的指针:第一次提交是没有直接祖先的,普通提交有一个祖先,由两个或多个分支合并产生的提交则有多个祖先。
	当使用git commit新建一个提交对象前,Git 会先计算每一个子目录(本例中就是项目根目录)的校验和,然后在 Git 仓库中将这些目录保存为树(tree)对象。之后 Git 创建的提交对象,除了包含相关提交信息以外,还包含着指向这个树对象(项目根目录)的指针,如此它就可以在将来需要的时候,重现此次快照的内容了。
	这些改变分别孤立在不同的分支里:我们可以在不同分支里反复切换,并在时机成熟时把它们合并到一起。而所有这些工作,仅仅需要branch和checkout这两条命令就可以完成。
	Git 中的分支,其实本质上仅仅是个指向 commit 对象的可变指针，它在每次提交的时候都会自动向前移动。从文本内容上看，Git 中的分支实际上仅是一个包含所指对象校验和(40 个字符长度 SHA-1 字串)的文件,所以创建和销毁一个分支就变得非常廉价。说白了,新建一个分支就是向一个文件写入 41 个字节(外加一个换行符)那么简单,当然也就很快了。
	请务必牢记当你在使用分支及合并的时候,一切都是在你自己的 Git 仓库中进行的 —— 完全不涉及与服务器的交互。
	“Fast forward快进提示:
		如果顺着一个分支走下去可以到达另一个分支,那么 Git 在合并两者时,只会简单地把指针前移,因为没有什么分歧需要解决,所以这个过程叫做快进提示。
	合并提交(merge commit)：

4.远程分支(remote branch)：
	远程分支是对远程仓库状态的索引。它们是一些无法移动的本地分支;只有在进行 Git的网络活动时才会更新。远程分支就像是书签,提醒着你上次连接远程仓库时上面各分支的位置
	我们用(远程仓库名)/(分支名)这样的形式表示远程分支。
	要想和其他人分享某个分支,你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程分支中,除非你明确执行推送操作。
	跟踪分支(tracking branch):
		从远程分支检出的本地分支,称为跟踪分支(tracking branch)。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入这些分支里运行git push ,Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来,在会获取所有远程索引,并把它们的数据都合并到本地分支中来。
	

5.衍合:
	把一个分支整合到另一个分支的办法有两种: merge(合并) 和rebase(衍合)
最容易的整合分支的方法是merge命令,它会把两个分支最新的快照(C3 和 C4)以及二者最新的共同祖先(C2)进行三方合并。【见图】	
	它的原理是回到两个分支(你所在的分支和你想要衍合进去的分支)的共同祖先,提取你所在分支每次提交时产生的差异(diff),把这些差异分别保存到临时文件里,然后从当前分支转换到你需要衍合入的分支,依序施用每一个差异补丁文件。现在,你可以回到 master 分支然后进行一次快进合并。
	合并后的 C3(即现在的 C3’)所指的快照,同三方合并例子中的 C5 所指的快照内容一模一样了。最后整合得到的结果没有任何区别,但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录,看起来更清楚:仿佛所有修改都是先后进行的,尽管实际上它们原来是同时发生的。
6.回退：
	git reset --hard/--soft 与 git revert 的说明：
	6.1 git reset --hard xxx
		修改版本库，修改暂存区，修改工作区
		--hard HEAD~1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本
	6.2 git reset --soft xxx
		修改版本库，保留暂存区，保留工作区
		--soft HEAD~1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。
	6.3 git revert xxx
		reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit，指针向后移动。

	git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。看似达到的效果是一样的,其实完全不同.
	第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.
	第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.
	第三: reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,新的commit的内容正好能够抵消要被revert的内容，他的 HEAD 是一直向前的.


6.git托管服务：
	6.1 派生(fork)项目：
		如果想向一个自己没有推送权限的项目贡献代码,GitHub 提倡使用派生(forking)。可以点击页面上方的 “fork(派生)” 按钮,GitHub 会为你的用户复制一份该项目,这样你就可以向它推送内容了。
		使用这个办法,项目维护者不用操心为了推送权限把其他人加为合作者的麻烦。大家可以派生一个项目副本并进行推送,而后项目的主要维护者可以把这些副本添加为远程仓库,从中拉取更新的内容进行合并。

	







